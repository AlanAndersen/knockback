// Generated by CoffeeScript 1.3.3

/*
  knockback.js 0.16.0beta2
  (c) 2011, 2012 Kevin Malakoff.
  Knockback.js is freely distributable under the MIT license.
  See the following for full license details:
    https://github.com/kmalakoff/knockback/blob/master/LICENSE
  Dependencies: Knockout.js, Backbone.js, and Underscore.js.
    Optional dependency: Backbone.ModelRef.js.
*/


(function() {
  var Backbone, Knockback, kb, ko, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  if (typeof require !== 'undefined') {
    try {
      _ = require('lodash');
    } catch (e) {
      _ = require('underscore');
    }
  } else {
    _ = this._;
  }

  if (_ && (_.hasOwnProperty('_'))) {
    _ = _._;
  }

  Backbone = !this.Backbone && (typeof require !== 'undefined') ? require('backbone') : this.Backbone;

  ko = !this.ko && (typeof require !== 'undefined') ? require('knockout') : this.ko;

  Knockback = kb = this.Knockback = this.kb = typeof exports !== 'undefined' ? exports : {};

  kb.VERSION = '0.16.0beta2';

  kb.locale_manager = void 0;

  kb.TYPE_UNKNOWN = 0;

  kb.TYPE_SIMPLE = 1;

  kb.TYPE_MODEL = 2;

  kb.TYPE_COLLECTION = 3;

  /*
    knockback_statistics.js
    (c) 2012 Kevin Malakoff.
    Knockback.Stats is freely distributable under the MIT license.
    See the following for full license details:
      https://github.com/kmalakoff/knockback/blob/master/LICENSE
  */


  kb.Statistics = (function() {

    function Statistics() {
      this.type_trackers = {};
    }

    Statistics.prototype.typeTracker = function(type) {
      var type_tracker;
      if (this.type_trackers.hasOwnProperty(type)) {
        return this.type_trackers[type];
      }
      type_tracker = [];
      this.type_trackers[type] = type_tracker;
      return type_tracker;
    };

    Statistics.prototype.register = function(type, obj) {
      return this.typeTracker(type).push(obj);
    };

    Statistics.prototype.unregister = function(type, obj) {
      var index, type_tracker;
      type_tracker = this.typeTracker(type);
      index = _.indexOf(type_tracker, obj);
      if (index < 0) {
        throw "failed to unregister type: " + type;
      }
      return type_tracker.splice(index, 1);
    };

    Statistics.prototype.registeredCount = function(type) {
      return this.typeTracker(type).length;
    };

    return Statistics;

  })();

  /*
    knockback_utils.js
    (c) 2011, 2012 Kevin Malakoff.
    Knockback.js is freely distributable under the MIT license.
    See the following for full license details:
      https://github.com/kmalakoff/knockback/blob/master/LICENSE
    Dependencies: Knockout.js, Backbone.js, and Underscore.js.
      Optional dependency: Backbone.ModelRef.js.
  */


  kb.utils = {};

  kb.utils.legacyWarning = function(identifier, last_version, message) {
    var _base;
    kb._legacy_warnings || (kb._legacy_warnings = {});
    (_base = kb._legacy_warnings)[identifier] || (_base[identifier] = 0);
    kb._legacy_warnings[identifier]++;
    return console.warn("warning: '" + identifier + "' has been deprecated (will be removed in Knockback after " + last_version + "). " + message + ".");
  };

  kb.utils.throwMissing = function(instance, message) {
    throw "" + instance.constructor.name + ": " + message + " is missing";
  };

  kb.utils.throwUnexpected = function(instance, message) {
    throw "" + instance.constructor.name + ": " + message + " is unexpected";
  };

  kb.utils.wrappedDestroy = function(owner) {
    var __kb;
    if (!owner.__kb) {
      return;
    }
    if (owner.__kb.model_observable) {
      owner.__kb.model_observable.releaseCallbacks(owner);
    }
    __kb = owner.__kb;
    owner.__kb = null;
    if (__kb.value_observable) {
      if (__kb.store) {
        __kb.store.releaseObservable(__kb.value_observable(), __kb.store_is_owned);
      } else {
        kb.utils.release(__kb.value_observable());
      }
      kb.utils.release(__kb.value_observable);
    }
    if (__kb.observable) {
      kb.utils.wrappedDestroy(__kb.observable);
      if (__kb.observable.dispose) {
        __kb.observable.dispose();
      }
    }
    if (__kb.model_observable_is_owned) {
      __kb.model_observable.destroy();
    }
    if (__kb.store_is_owned) {
      return __kb.store.destroy();
    }
  };

  kb.utils.wrappedByKey = function(owner, key, value) {
    if (arguments.length === 2) {
      if (owner && owner.__kb && owner.__kb.hasOwnProperty(key)) {
        return owner.__kb[key];
      } else {
        return void 0;
      }
    }
    if (!owner) {
      throw "Knockback: no owner for wrapping " + key;
    }
    owner.__kb || (owner.__kb = {});
    owner.__kb[key] = value;
    return value;
  };

  kb.utils.wrappedObservable = function(instance, observable) {
    if (arguments.length === 1) {
      return kb.utils.wrappedByKey(instance, 'observable');
    }
    kb.utils.wrappedByKey(instance, 'observable', observable);
    if (observable) {
      kb.utils.wrappedByKey(observable, 'instance', instance);
    }
    return observable;
  };

  kb.utils.wrappedModel = function(observable, value) {
    var obj;
    if (arguments.length === 1) {
      obj = kb.utils.wrappedByKey(observable, 'obj');
      if (_.isUndefined(obj)) {
        return observable;
      } else {
        return obj;
      }
    } else {
      return kb.utils.wrappedByKey(observable, 'obj', value);
    }
  };

  kb.utils.wrappedObject = function(observable, value) {
    if (arguments.length === 1) {
      return kb.utils.wrappedByKey(observable, 'obj');
    } else {
      return kb.utils.wrappedByKey(observable, 'obj', value);
    }
  };

  kb.utils.wrappedStore = function(observable, value) {
    if (arguments.length === 1) {
      return kb.utils.wrappedByKey(observable, 'store');
    } else {
      return kb.utils.wrappedByKey(observable, 'store', value);
    }
  };

  kb.utils.wrappedStoreIsOwned = function(observable, value) {
    if (arguments.length === 1) {
      return kb.utils.wrappedByKey(observable, 'store_is_owned');
    } else {
      return kb.utils.wrappedByKey(observable, 'store_is_owned', value);
    }
  };

  kb.utils.wrappedFactory = function(observable, value) {
    if (arguments.length === 1) {
      return kb.utils.wrappedByKey(observable, 'factory');
    } else {
      return kb.utils.wrappedByKey(observable, 'factory', value);
    }
  };

  kb.utils.wrappedPath = function(observable, value) {
    if (arguments.length === 1) {
      return kb.utils.wrappedByKey(observable, 'path');
    } else {
      return kb.utils.wrappedByKey(observable, 'path', value);
    }
  };

  kb.utils.wrappedModelObservable = function(observable, value) {
    if (arguments.length === 1) {
      return kb.utils.wrappedByKey(observable, 'model_observable');
    } else {
      return kb.utils.wrappedByKey(observable, 'model_observable', value);
    }
  };

  kb.utils.wrappedModelObservableIsOwned = function(observable, value) {
    if (arguments.length === 1) {
      return kb.utils.wrappedByKey(observable, 'model_observable_is_owned');
    } else {
      return kb.utils.wrappedByKey(observable, 'model_observable_is_owned', value);
    }
  };

  kb.utils.setToDefault = function(obj) {
    var key, observable;
    if (!obj) {
      return;
    }
    if (ko.isObservable(obj)) {
      if (typeof obj.setToDefault === "function") {
        obj.setToDefault();
      }
    } else if (_.isObject(obj)) {
      for (key in obj) {
        observable = obj[key];
        if (observable && (key !== '__kb')) {
          kb.utils.setToDefault(observable);
        }
      }
    }
    return obj;
  };

  kb.utils.release = function(obj, keys_only) {
    var key, value;
    if (!obj) {
      return false;
    }
    if (!keys_only && (ko.isObservable(obj) || (obj instanceof kb.Observables) || (typeof obj.release === 'function') || (typeof obj.destroy === 'function'))) {
      if (obj.release) {
        obj.release();
      } else if (obj.destroy) {
        obj.destroy();
      } else if (obj.dispose) {
        obj.dispose();
      }
      return true;
    } else if (_.isObject(obj) && !(typeof obj === 'function')) {
      for (key in obj) {
        value = obj[key];
        if (!value || (key === '__kb') || ((typeof value === 'function') && !ko.isObservable(value))) {
          continue;
        }
        if (kb.utils.release(value)) {
          obj[key] = null;
        }
      }
      return true;
    }
    return false;
  };

  kb.utils.valueType = function(observable) {
    var instance;
    if (!observable) {
      return kb.TYPE_UNKNOWN;
    }
    if (observable instanceof kb.ViewModel) {
      return kb.TYPE_MODEL;
    }
    if (!(observable.__kb && observable.__kb.instance)) {
      if (observable instanceof Backbone.Model) {
        return kb.TYPE_MODEL;
      }
      if (observable instanceof Backbone.Collection) {
        return kb.TYPE_COLLECTION;
      }
      return kb.TYPE_SIMPLE;
    }
    instance = observable.__kb.instance;
    if (instance instanceof kb.Observable) {
      return observable.valueType();
    }
    if (instance instanceof kb.CollectionObservable) {
      return kb.TYPE_COLLECTION;
    }
    return kb.TYPE_SIMPLE;
  };

  kb.utils.observableInstanceOf = function(observable, type) {
    if (!observable) {
      return false;
    }
    if (!(observable.__kb && observable.__kb.instance)) {
      return false;
    }
    return observable.__kb.instance instanceof type;
  };

  kb.utils.pathJoin = function(path1, path2) {
    var path;
    if (!path1) {
      path = '';
    } else {
      path = path1[path1.length - 1] !== '.' ? "" + path1 + "." : path1;
    }
    path += path2;
    return path;
  };

  kb.utils.optionsPathJoin = function(options, path) {
    return _.defaults({
      path: kb.utils.pathJoin(options.path, path)
    }, options);
  };

  /*
    knockback_ref_countable.js
    (c) 2012 Kevin Malakoff.
    Knockback.RefCountable is freely distributable under the MIT license.
    See the following for full license details:
      https://github.com/kmalakoff/knockback/blob/master/LICENSE
  */


  kb.RefCountable = (function() {

    RefCountable.extend = Backbone.Model.extend;

    function RefCountable() {
      this.__kb_ref_count = 1;
    }

    RefCountable.prototype.__destroy = function() {};

    RefCountable.prototype.retain = function() {
      if (this.__kb_ref_count <= 0) {
        throw "RefCountable: ref_count is corrupt: " + this.__kb_ref_count;
      }
      this.__kb_ref_count++;
      return this;
    };

    RefCountable.prototype.release = function(all) {
      if (this.__kb_ref_count <= 0) {
        throw "RefCountable: ref_count is corrupt: " + this.__kb_ref_count;
      }
      if (all) {
        this.__kb_ref_count = 0;
      } else {
        this.__kb_ref_count--;
      }
      if (!this.__kb_ref_count) {
        this.__destroy();
      }
      return this;
    };

    RefCountable.prototype.refCount = function() {
      return this.__kb_ref_count;
    };

    return RefCountable;

  })();

  /*
    knockback_factory.js
    (c) 2011, 2012 Kevin Malakoff.
    Knockback.Factory is freely distributable under the MIT license.
    See the following for full license details:
      https://github.com/kmalakoff/knockback/blob/master/LICENSE
  */


  kb.Factory = (function() {

    function Factory(parent_factory) {
      this.parent_factory = parent_factory;
      this.paths = {};
    }

    Factory.prototype.hasPath = function(path) {
      return this.paths.hasOwnProperty(path) || (this.parent_factory && this.parent_factory.hasPath(path));
    };

    Factory.prototype.addPathMapping = function(path, create_info) {
      return this.paths[path] = create_info;
    };

    Factory.prototype.addPathMappings = function(mappings) {
      var create_info, path;
      for (path in mappings) {
        create_info = mappings[path];
        this.paths[path] = create_info;
      }
      return this;
    };

    Factory.prototype.creatorForPath = function(obj, path) {
      var creator;
      creator = this.paths[path];
      if (creator) {
        if (creator.view_model) {
          return creator.view_model;
        } else {
          return creator;
        }
      }
      if (this.parent_factory) {
        creator = this.parent_factory.creatorForPath(obj, path);
        if (creator) {
          return creator;
        }
      }
      if (obj instanceof Backbone.Model) {
        return kb.ViewModel;
      }
      if (obj instanceof Backbone.Collection) {
        return kb.CollectionObservable;
      }
      return null;
    };

    Factory.prototype.createForPath = function(obj, path, store, creator) {
      if (!creator) {
        creator = this.creatorForPath(obj, path);
      }
      if (!creator) {
        return ko.observable(obj);
      }
      if (creator.hasOwnProperty('models_only')) {
        return obj(creator.models_only);
        return kb.Factory.createDefault(obj, {
          store: store,
          factory: this,
          path: path
        });
      }
      if (typeof creator === 'function') {
        return new creator(obj, {
          store: store,
          factory: this,
          path: path,
          creator: creator
        });
      }
      if (creator.create) {
        return creator.create(obj, {
          store: store,
          factory: this,
          path: path,
          creator: creator
        });
      }
      throw "unrecognized creator for " + path;
    };

    Factory.createDefault = function(obj, options) {
      if (obj instanceof Backbone.Model) {
        return kb.viewModel(obj, options);
      }
      if (obj instanceof Backbone.Collection) {
        return kb.collectionObservable(obj, options);
      }
      return ko.observable(obj);
    };

    return Factory;

  })();

  /*
    knockback_store.js
    (c) 2012 Kevin Malakoff.
    Knockback.Store is freely distributable under the MIT license.
    See the following for full license details:
      https://github.com/kmalakoff/knockback/blob/master/LICENSE
  */


  kb.Store = (function() {

    Store.useOptionsOrCreate = function(options, obj, observable) {
      var store;
      if (options.store) {
        store = kb.utils.wrappedStore(observable, options.store);
        options.store.registerObservable(obj, observable, options);
      } else {
        store = kb.utils.wrappedStore(observable, new kb.Store());
        kb.utils.wrappedStoreIsOwned(observable, true);
      }
      return store;
    };

    function Store() {
      this.objects = [];
      this.observables = [];
    }

    Store.prototype.destroy = function() {
      var index, observable, _ref, _ref1;
      this.objects = null;
      _ref = this.observables;
      for (index in _ref) {
        observable = _ref[index];
        if (!kb.utils.observableInstanceOf(observable, kb.CollectionObservable)) {
          continue;
        }
        this.observables[index] = null;
        observable.release(true);
      }
      _ref1 = this.observables;
      for (index in _ref1) {
        observable = _ref1[index];
        if (!observable) {
          continue;
        }
        this.observables[index] = null;
        if (observable && observable.release) {
          observable.release(true);
        } else {
          kb.utils.release(observable);
        }
      }
      return this.observables = null;
    };

    Store.prototype.registerObservable = function(obj, observable, options) {
      if (options == null) {
        options = {};
      }
      if (!obj) {
        return;
      }
      this.objects.push(obj);
      kb.utils.wrappedObject(observable, obj);
      this.observables.push(observable);
      if (typeof observable.retain === "function") {
        observable.retain();
      }
      observable.__kb || (observable.__kb = {});
      if (options.creator) {
        return observable.__kb.creator = options.creator;
      } else if (options.path && options.factory) {
        return observable.__kb.creator = options.factory.creatorForPath(obj, options.path);
      } else {
        return observable.__kb.creator = null;
      }
    };

    Store.prototype.findOrCreateObservable = function(obj, path, factory) {
      var creator, index, observable, test, _i, _len, _ref;
      if (!factory) {
        observable = kb.Factory.createDefault(obj, {
          path: path
        });
      } else {
        creator = factory.creatorForPath(obj, path);
        if (!creator) {
          return ko.observable(obj);
        }
        if (creator.models_only) {
          return obj;
        }
        if (!(obj instanceof Backbone.Collection)) {
          _ref = this.objects;
          for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
            test = _ref[index];
            observable = this.observables[index];
            if ((test === obj) && (observable.__kb.creator === creator)) {
              if (typeof observable.retain === "function") {
                observable.retain();
              }
              return observable;
            }
          }
        }
        observable = factory.createForPath(obj, path, this, creator);
        if (!observable) {
          observable = ko.observable(null);
        }
      }
      index = _.indexOf(this.observables, observable);
      if (index < 0) {
        this.registerObservable(obj, observable, {
          creator: creator
        });
      }
      return observable;
    };

    Store.prototype.releaseObservable = function(observable, owns_store) {
      var index;
      if (!this.objects) {
        return;
      }
      if (!observable) {
        return;
      }
      index = _.indexOf(this.observables, observable);
      if (!(index >= 0)) {
        return;
      }
      if (arguments.length === 2 && !owns_store && !observable.release) {
        return;
      }
      kb.utils.release(observable);
      if (observable.refCount && observable.refCount() > 0) {
        return;
      }
      kb.utils.wrappedObject(observable, null);
      if (!this.objects) {
        return;
      }
      if (this.observables[index] !== observable) {
        index = _.indexOf(this.observables, observable);
      }
      this.objects[index] = null;
      return this.observables[index] = null;
    };

    return Store;

  })();

  /*
    knockback_model_observable.js
    (c) 2011, 2012 Kevin Malakoff.
    Knockback.Observable is freely distributable under the MIT license.
    See the following for full license details:
      https://github.com/kmalakoff/knockback/blob/master/LICENSE
  */


  kb.ModelObservable = (function() {

    ModelObservable.useOptionsOrCreate = function(options, model, obj, callback_options) {
      var model_observable;
      if (options.model_observable && options.model_observable.model() === model) {
        model_observable = kb.utils.wrappedModelObservable(obj, options.model_observable);
      } else {
        model_observable = kb.utils.wrappedModelObservable(obj, new kb.ModelObservable(model));
        kb.utils.wrappedModelObservableIsOwned(obj, true);
      }
      model_observable.registerCallbacks(obj, callback_options);
      return model_observable;
    };

    function ModelObservable(model, obj, callback_options) {
      this._onModelUnloaded = __bind(this._onModelUnloaded, this);

      this._onModelLoaded = __bind(this._onModelLoaded, this);
      this.__kb || (this.__kb = {});
      this.__kb.callbacks = {};
      this.__kb._onModelLoaded = _.bind(this._onModelLoaded, this);
      this.__kb._onModelUnloaded = _.bind(this._onModelUnloaded, this);
      if (callback_options) {
        this.registerCallbacks(obj, callback_options);
      }
      if (model) {
        this.model(model);
      }
    }

    ModelObservable.prototype.destroy = function() {
      this.model(null);
      this.__kb.callbacks = null;
      return kb.utils.wrappedDestroy(this);
    };

    ModelObservable.prototype.model = function(new_model) {
      var callbacks, event_name, info, list, model, _i, _len, _ref;
      model = kb.utils.wrappedObject(this);
      if ((arguments.length === 0) || (model === new_model)) {
        return model;
      }
      if (this.model_ref) {
        this.model_ref.unbind('loaded', this.__kb._onModelLoaded);
        this.model_ref.unbind('unloaded', this.__kb._onModelUnloaded);
        this.model_ref.release();
        this.model_ref = null;
      }
      if (Backbone.ModelRef && (new_model instanceof Backbone.ModelRef)) {
        this.model_ref = new_model;
        this.model_ref.retain();
        this.model_ref.bind('loaded', this.__kb._onModelLoaded);
        this.model_ref.bind('unloaded', this.__kb._onModelUnloaded);
        new_model = this.model_ref.model();
      } else {
        delete this.model_ref;
      }
      kb.utils.wrappedObject(this, new_model);
      _ref = this.__kb.callbacks;
      for (event_name in _ref) {
        callbacks = _ref[event_name];
        if (model) {
          this._modelUnbindEvent(model, event_name, callbacks);
        }
        if (new_model) {
          this._modelBindEvent(new_model, event_name, callbacks);
        }
        list = callbacks.list;
        for (_i = 0, _len = list.length; _i < _len; _i++) {
          info = list[_i];
          if (info.model) {
            info.model(new_model);
          }
        }
      }
      return new_model;
    };

    ModelObservable.prototype.registerCallbacks = function(obj, options) {
      var callbacks, event_name, info, list, model;
      if (!obj) {
        kb.utils.throwMissing(this, 'obj');
      }
      if (!options) {
        kb.utils.throwMissing(this, 'options');
      }
      model = kb.utils.wrappedObject(this);
      event_name = options.event_name ? options.event_name : 'change';
      callbacks = this.__kb.callbacks[event_name];
      if (!callbacks) {
        list = [];
        callbacks = {
          list: list,
          fn: function(model) {
            var info, _i, _len;
            for (_i = 0, _len = list.length; _i < _len; _i++) {
              info = list[_i];
              if (!info.update) {
                continue;
              }
              if (model && info.key && (model.hasChanged && !model.hasChanged(ko.utils.unwrapObservable(info.key)))) {
                continue;
              }
              info.update();
            }
            return null;
          }
        };
        this.__kb.callbacks[event_name] = callbacks;
        if (model) {
          this._modelBindEvent(model, event_name, callbacks);
        }
      }
      info = {};
      info.obj = obj;
      if (options.model) {
        info.model = options.model;
      }
      if (options.update) {
        info.update = options.update;
      }
      if (options.key) {
        info.key = options.key;
      }
      callbacks.list.push(info);
      if (!model) {
        return;
      }
      if (Backbone.RelationalModel && (model instanceof Backbone.RelationalModel)) {
        this._modelBindRelatationalInfo(model, event_name, info);
      }
      return info.model(model) && info.model;
    };

    ModelObservable.prototype.releaseCallbacks = function(obj) {
      var callbacks, event_name, index, info, model, _ref, _ref1;
      if (!this.__kb.callbacks) {
        return;
      }
      model = kb.utils.wrappedObject(this);
      _ref = this.__kb.callbacks;
      for (event_name in _ref) {
        callbacks = _ref[event_name];
        _ref1 = callbacks.list;
        for (index in _ref1) {
          info = _ref1[index];
          if (info.obj === obj) {
            callbacks.list.splice(index, 1);
            if (Backbone.RelationalModel && (model instanceof Backbone.RelationalModel)) {
              this._modelUnbindRelatationalInfo(model, event_name, info);
            }
            if (info.model) {
              info.model(null);
            }
            return;
          }
        }
      }
    };

    ModelObservable.prototype._onModelLoaded = function(model) {
      var callbacks, event_name, info, is_relational, list, _i, _len, _ref;
      is_relational = Backbone.RelationalModel && (model instanceof Backbone.RelationalModel);
      kb.utils.wrappedObject(this, model);
      _ref = this.__kb.callbacks;
      for (event_name in _ref) {
        callbacks = _ref[event_name];
        this._modelBindEvent(model, event_name, callbacks);
        list = callbacks.list;
        for (_i = 0, _len = list.length; _i < _len; _i++) {
          info = list[_i];
          if (is_relational) {
            this._modelBindRelatationalInfo(model, event_name, info);
          }
          if (info.model) {
            info.model(model);
          }
        }
      }
      return this;
    };

    ModelObservable.prototype._onModelUnloaded = function(model) {
      var callbacks, event_name, info, is_relational, list, _i, _len, _ref;
      is_relational = Backbone.RelationalModel && (model instanceof Backbone.RelationalModel);
      kb.utils.wrappedObject(this, null);
      _ref = this.__kb.callbacks;
      for (event_name in _ref) {
        callbacks = _ref[event_name];
        this._modelUnbindEvent(model, event_name, callbacks);
        list = callbacks.list;
        for (_i = 0, _len = list.length; _i < _len; _i++) {
          info = list[_i];
          if (is_relational) {
            this._modelUnbindRelatationalInfo(model, event_name, info);
          }
          if (info.model) {
            info.model(null);
          }
        }
      }
      return this;
    };

    ModelObservable.prototype._modelBindEvent = function(model, event_name, callbacks) {
      model.bind(event_name, callbacks.fn);
      return this;
    };

    ModelObservable.prototype._modelUnbindEvent = function(model, event_name, callbacks) {
      model.unbind(event_name, callbacks.fn);
      return this;
    };

    ModelObservable.prototype._modelBindRelatationalInfo = function(model, event_name, info) {
      if ((event_name === 'change') && info.key && info.update) {
        info.rel_fn = function() {
          return info.update();
        };
        model.bind("add:" + info.key, info.rel_fn);
        model.bind("remove:" + info.key, info.rel_fn);
        model.bind("update:" + info.key, info.rel_fn);
      }
      return this;
    };

    ModelObservable.prototype._modelUnbindRelatationalInfo = function(model, event_name, info) {
      if ((event_name === 'change') && info.key && info.update) {
        model.unbind("add:" + info.key, info.rel_fn);
        model.unbind("remove:" + info.key, info.rel_fn);
        model.unbind("update:" + info.key, info.rel_fn);
        info.rel_fn = null;
      }
      return this;
    };

    return ModelObservable;

  })();

  kb.modelObservable = function(model, observable) {
    return new kb.ModelObservable(model, observable);
  };

  /*
    knockback_collection_observable.js
    (c) 2011, 2012 Kevin Malakoff.
    Knockback.CollectionObservable is freely distributable under the MIT license.
    See the following for full license details:
      https://github.com/kmalakoff/knockback/blob/master/LICENSE
  */


  kb.CollectionObservable = (function(_super) {

    __extends(CollectionObservable, _super);

    function CollectionObservable(collection, options) {
      var factory, observable;
      if (options == null) {
        options = {};
      }
      if (!collection) {
        kb.utils.throwMissing(this, 'collection');
      }
      CollectionObservable.__super__.constructor.apply(this, arguments);
      if (kb.statistics) {
        kb.statistics.register('kb.CollectionObservable', this);
      }
      observable = kb.utils.wrappedObservable(this, ko.observableArray([]));
      this.in_edit = 0;
      this.__kb || (this.__kb = {});
      this.__kb._onCollectionReset = _.bind(this._onCollectionReset, this);
      this.__kb._onCollectionResort = _.bind(this._onCollectionResort, this);
      this.__kb._onModelAdd = _.bind(this._onModelAdd, this);
      this.__kb._onModelRemove = _.bind(this._onModelRemove, this);
      this.__kb._onModelChange = _.bind(this._onModelChange, this);
      kb.Store.useOptionsOrCreate(options, collection, observable);
      factory = kb.utils.wrappedFactory(observable, new kb.Factory(options.factory));
      if (options.mappings) {
        factory.addPathMappings(options.mappings);
      }
      kb.utils.wrappedPath(observable, options.path);
      this.models_path = kb.utils.pathJoin(options.path, 'models');
      if (!factory.hasPath(this.models_path)) {
        if (options.hasOwnProperty('models_only')) {
          if (options.models_only) {
            factory.addPathMapping(this.models_path, {
              models_only: options.models_only
            });
            this.models_only = options.models_only;
          } else {
            factory.addPathMapping(this.models_path, kb.ViewModel);
          }
        } else if (options.view_model) {
          factory.addPathMapping(this.models_path, options.view_model);
        } else if (options.create) {
          factory.addPathMapping(this.models_path, {
            create: options.create
          });
        } else {
          factory.addPathMapping(this.models_path, kb.ViewModel);
        }
      }
      this.sort_attribute = options.sort_attribute;
      this.sorted_index = options.sorted_index;
      observable.retain = _.bind(this.retain, this);
      observable.refCount = _.bind(this.refCount, this);
      observable.release = _.bind(this.release, this);
      observable.collection = _.bind(this.collection, this);
      observable.viewModelByModel = _.bind(this.viewModelByModel, this);
      observable.sortedIndex = _.bind(this.sortedIndex, this);
      observable.sortAttribute = _.bind(this.sortAttribute, this);
      observable.hasViewModels = _.bind(this.hasViewModels, this);
      observable.bind = _.bind(this.bind, this);
      observable.unbind = _.bind(this.unbind, this);
      observable.trigger = _.bind(this.trigger, this);
      kb.utils.wrappedObject(observable, null);
      this.collection(collection, {
        silent: true,
        'defer': options['defer']
      });
      observable.subscribe(_.bind(this._onObservableArrayChange, this));
      return observable;
    }

    CollectionObservable.prototype.__destroy = function() {
      var collection, observable;
      observable = kb.utils.wrappedObservable(this);
      collection = kb.utils.wrappedObject(observable);
      if (collection) {
        this._collectionUnbind(collection);
        this._clear(true);
        collection = kb.utils.wrappedObject(observable, null);
      }
      kb.utils.wrappedDestroy(this);
      CollectionObservable.__super__.__destroy.apply(this, arguments);
      if (kb.statistics) {
        return kb.statistics.unregister('kb.CollectionObservable', this);
      }
    };

    CollectionObservable.prototype.retain = function() {
      CollectionObservable.__super__.retain.apply(this, arguments);
      return kb.utils.wrappedObservable(this);
    };

    CollectionObservable.prototype.release = function() {
      var observable;
      observable = kb.utils.wrappedObservable(this);
      CollectionObservable.__super__.release.apply(this, arguments);
      return observable;
    };

    CollectionObservable.prototype.collection = function(collection, options) {
      var observable, previous_collection;
      observable = kb.utils.wrappedObservable(this);
      previous_collection = kb.utils.wrappedObject(observable);
      if (arguments.length === 0) {
        observable();
        return previous_collection;
      }
      if (collection === previous_collection) {
        return;
      }
      if (collection != null) {
        if (typeof collection.retain === "function") {
          collection.retain();
        }
      }
      if (previous_collection) {
        this._collectionUnbind(previous_collection);
        if (typeof previous_collection.release === "function") {
          previous_collection.release();
        }
      }
      kb.utils.wrappedObject(observable, collection);
      if (collection) {
        this._collectionBind(collection);
        this.sortedIndex(this.sorted_index, this.sort_attribute, options);
      } else {
        this._clear();
      }
      return collection;
    };

    CollectionObservable.prototype.sortedIndex = function(sorted_index, sort_attribute, options) {
      var _resync,
        _this = this;
      if (options == null) {
        options = {};
      }
      if (sorted_index) {
        this.sorted_index = sorted_index;
        this.sort_attribute = sort_attribute;
      } else if (sort_attribute) {
        this.sort_attribute = sort_attribute;
        this.sorted_index = this._sortAttributeFn(sort_attribute);
      } else {
        this.sort_attribute = null;
        this.sorted_index = null;
      }
      _resync = function() {
        var collection, observable;
        observable = kb.utils.wrappedObservable(_this);
        collection = kb.utils.wrappedObject(observable);
        if ((collection.models.length === 0) && (observable().length === 0)) {
          return;
        }
        _this._collectionResync(true);
        if (!options.silent) {
          return _this.trigger('resort', observable());
        }
      };
      if (options['defer']) {
        _.defer(_resync);
      } else {
        _resync();
      }
      return this;
    };

    CollectionObservable.prototype.sortAttribute = function(sort_attribute, sorted_index, silent) {
      return this.sortedIndex(sorted_index, sort_attribute, silent);
    };

    CollectionObservable.prototype.viewModelByModel = function(model) {
      var id_attribute, observable;
      if (!this.hasViewModels()) {
        return null;
      }
      observable = kb.utils.wrappedObservable(this);
      id_attribute = model.hasOwnProperty(model.idAttribute) ? model.idAttribute : 'cid';
      return _.find(observable(), function(test) {
        return test.__kb.obj[id_attribute] === model[id_attribute];
      });
    };

    CollectionObservable.prototype.hasViewModels = function() {
      return !this.models_only;
    };

    CollectionObservable.prototype._collectionBind = function(collection) {
      var event, _i, _j, _len, _len1, _ref, _ref1;
      collection.bind('reset', this.__kb._onCollectionReset);
      if (!this.sorted_index) {
        collection.bind('resort', this.__kb._onCollectionResort);
      }
      _ref = ['new', 'add'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        event = _ref[_i];
        collection.bind(event, this.__kb._onModelAdd);
      }
      _ref1 = ['remove', 'destroy'];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        event = _ref1[_j];
        collection.bind(event, this.__kb._onModelRemove);
      }
      return collection.bind('change', this.__kb._onModelChange);
    };

    CollectionObservable.prototype._collectionUnbind = function(collection) {
      var event, _i, _j, _len, _len1, _ref, _ref1;
      collection.unbind('reset', this.__kb._onCollectionReset);
      if (!this.sorted_index) {
        collection.unbind('resort', this.__kb._onCollectionResort);
      }
      _ref = ['new', 'add'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        event = _ref[_i];
        collection.unbind(event, this.__kb._onModelAdd);
      }
      _ref1 = ['remove', 'destroy'];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        event = _ref1[_j];
        collection.unbind(event, this.__kb._onModelRemove);
      }
      return collection.unbind('change', this.__kb._onModelChange);
    };

    CollectionObservable.prototype._onCollectionReset = function() {
      if (this.in_edit) {
        return;
      }
      return this._collectionResync();
    };

    CollectionObservable.prototype._onCollectionResort = function(model_or_models) {
      var observable;
      if (this.sorted_index) {
        kb.utils.throwUnexpected(this, 'sorted_index');
      }
      if (_.isArray(model_or_models)) {
        observable = kb.utils.wrappedObservable(this);
        return this.trigger('resort', observable());
      } else {
        return this._onModelResort(model_or_models);
      }
    };

    CollectionObservable.prototype._onModelAdd = function(model) {
      var add_index, collection, observable, view_model;
      view_model = this._createViewModel(model);
      observable = kb.utils.wrappedObservable(this);
      collection = kb.utils.wrappedObject(observable);
      if (this.sorted_index) {
        add_index = this.sorted_index(observable(), view_model);
      } else {
        add_index = collection.indexOf(model);
      }
      this.in_edit++;
      observable.splice(add_index, 0, view_model);
      this.in_edit--;
      return this.trigger('add', view_model, observable());
    };

    CollectionObservable.prototype._onModelRemove = function(model) {
      var observable, view_model;
      view_model = this.hasViewModels() ? this.viewModelByModel(model) : model;
      if (!view_model) {
        return;
      }
      observable = kb.utils.wrappedObservable(this);
      this.in_edit++;
      observable.remove(view_model);
      this.in_edit--;
      this.trigger('remove', view_model, observable);
      if (this.hasViewModels()) {
        return kb.utils.wrappedStore(observable).releaseObservable(view_model, kb.utils.wrappedStoreIsOwned(observable));
      }
    };

    CollectionObservable.prototype._onModelChange = function(model) {
      if (this.sorted_index && (!this.sort_attribute || model.hasChanged(this.sort_attribute))) {
        return this._onModelResort(model);
      }
    };

    CollectionObservable.prototype._onModelResort = function(model) {
      var collection, new_index, observable, previous_index, sorted_view_models, view_model;
      observable = kb.utils.wrappedObservable(this);
      collection = kb.utils.wrappedObject(observable);
      view_model = this.hasViewModels() ? this.viewModelByModel(model) : model;
      previous_index = observable.indexOf(view_model);
      if (this.sorted_index) {
        sorted_view_models = _.clone(observable());
        sorted_view_models.splice(previous_index, 1);
        new_index = this.sorted_index(sorted_view_models, view_model);
      } else {
        new_index = collection.indexOf(model);
      }
      if (previous_index === new_index) {
        return;
      }
      this.in_edit++;
      observable.splice(previous_index, 1);
      observable.splice(new_index, 0, view_model);
      this.in_edit--;
      return this.trigger('resort', view_model, observable(), new_index);
    };

    CollectionObservable.prototype._onObservableArrayChange = function(values) {
      var collection, observable;
      if (this.in_edit) {
        return;
      }
      observable = kb.utils.wrappedObservable(this);
      collection = kb.utils.wrappedObject(observable);
      this.in_edit++;
      collection.reset(_.map(values, function(test) {
        return kb.utils.wrappedModel(test);
      }));
      return this.in_edit--;
    };

    CollectionObservable.prototype._clear = function(silent) {
      var array, observable, store, view_model, view_models, _i, _len;
      observable = kb.utils.wrappedObservable(this);
      if (!silent) {
        this.trigger('remove', observable());
      }
      this.in_edit++;
      if (silent) {
        array = observable();
        view_models = this.hasViewModels() ? array.slice(0) : null;
        array.splice(0, array.length);
      } else {
        view_models = observable.removeAll();
        if (!this.hasViewModels()) {
          view_models = null;
        }
      }
      this.in_edit--;
      if (!view_models) {
        return;
      }
      store = kb.utils.wrappedStore(observable);
      for (_i = 0, _len = view_models.length; _i < _len; _i++) {
        view_model = view_models[_i];
        store.releaseObservable(view_model, kb.utils.wrappedStoreIsOwned(observable));
      }
      return this;
    };

    CollectionObservable.prototype._collectionResync = function(silent) {
      var add_index, collection, model, observable, view_model, view_models, _i, _len, _ref,
        _this = this;
      this._clear(silent);
      observable = kb.utils.wrappedObservable(this);
      collection = kb.utils.wrappedObject(observable);
      if (this.sorted_index) {
        view_models = [];
        _ref = collection.models;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          model = _ref[_i];
          view_model = this._createViewModel(model);
          add_index = this.sorted_index(view_models, view_model);
          view_models.splice(add_index, 0, view_model);
        }
      } else {
        view_models = this.hasViewModels() ? _.map(collection.models, function(model) {
          return _this._createViewModel(model);
        }) : _.clone(collection.models);
      }
      this.in_edit++;
      observable(view_models);
      this.in_edit--;
      if (!silent) {
        return this.trigger('add', observable());
      }
    };

    CollectionObservable.prototype._sortAttributeFn = function(sort_attribute) {
      if (this.hasViewModels()) {
        return function(view_models, model) {
          return _.sortedIndex(view_models, model, function(test) {
            return kb.utils.wrappedModel(test).get(sort_attribute);
          });
        };
      } else {
        return function(models, model) {
          return _.sortedIndex(models, model, function(test) {
            return test.get(sort_attribute);
          });
        };
      }
    };

    CollectionObservable.prototype._createViewModel = function(model) {
      var observable;
      observable = kb.utils.wrappedObservable(this);
      if (this.hasViewModels()) {
        return kb.utils.wrappedStore(observable).findOrCreateObservable(model, this.models_path, kb.utils.wrappedFactory(observable));
      } else {
        return model;
      }
    };

    return CollectionObservable;

  })(kb.RefCountable);

  __extends(kb.CollectionObservable.prototype, Backbone.Events);

  kb.collectionObservable = function(collection, options) {
    return new kb.CollectionObservable(collection, options);
  };

  kb.sortedIndexWrapAttr = kb.siwa = function(attribute_name, wrapper_constructor) {
    return function(models, model) {
      return _.sortedIndex(models, model, function(test) {
        return new wrapper_constructor(kb.utils.wrappedModel(test).get(attribute_name));
      });
    };
  };

  /*
    knockback_default_wrapper.js
    (c) 2011, 2012 Kevin Malakoff.
    Knockback.DefaultWrapper is freely distributable under the MIT license.
    See the following for full license details:
      https://github.com/kmalakoff/knockback/blob/master/LICENSE
  */


  kb.DefaultWrapper = (function() {

    function DefaultWrapper(target_observable, default_value) {
      var observable,
        _this = this;
      this.default_value = default_value;
      observable = kb.utils.wrappedObservable(this, ko.dependentObservable({
        read: function() {
          var current_default, current_target;
          current_target = ko.utils.unwrapObservable(target_observable());
          current_default = ko.utils.unwrapObservable(_this.default_value);
          if (!current_target) {
            return current_default;
          } else {
            return current_target;
          }
        },
        write: function(value) {
          return target_observable(value);
        }
      }));
      observable.destroy = _.bind(this.destroy, this);
      observable.setToDefault = _.bind(this.setToDefault, this);
      return observable;
    }

    DefaultWrapper.prototype.destroy = function() {
      var _base;
      if (this.default_value) {
        if (typeof (_base = this.default_value).dispose === "function") {
          _base.dispose();
        }
        this.default_value = null;
      }
      return kb.utils.wrappedDestroy(this);
    };

    DefaultWrapper.prototype.setToDefault = function() {
      var observable;
      observable = kb.utils.wrappedObservable(this);
      return observable(this.default_value);
    };

    return DefaultWrapper;

  })();

  kb.defaultWrapper = function(target, default_value) {
    return new kb.DefaultWrapper(target, default_value);
  };

  /*
    knockback_formatted_observable.js
    (c) 2011, 2012 Kevin Malakoff.
    Knockback.FormattedObservable is freely distributable under the MIT license.
    See the following for full license details:
      https://github.com/kmalakoff/knockback/blob/master/LICENSE
  */


  kb.toFormattedString = function(format) {
    var arg, args, index, parameter_index, result, value;
    result = format.slice();
    args = Array.prototype.slice.call(arguments, 1);
    for (index in args) {
      arg = args[index];
      value = ko.utils.unwrapObservable(arg);
      if (!value) {
        value = '';
      }
      parameter_index = format.indexOf("\{" + index + "\}");
      while (parameter_index >= 0) {
        result = result.replace("{" + index + "}", value);
        parameter_index = format.indexOf("\{" + index + "\}", parameter_index + 1);
      }
    }
    return result;
  };

  kb.parseFormattedString = function(string, format) {
    var count, format_indices_to_matched_indices, index, match_index, matches, parameter_count, parameter_index, positions, regex, regex_string, results, sorted_positions;
    regex_string = format.slice();
    index = 0;
    parameter_count = 0;
    positions = {};
    while (regex_string.search("\\{" + index + "\\}") >= 0) {
      parameter_index = format.indexOf("\{" + index + "\}");
      while (parameter_index >= 0) {
        regex_string = regex_string.replace("\{" + index + "\}", '(.*)');
        positions[parameter_index] = index;
        parameter_count++;
        parameter_index = format.indexOf("\{" + index + "\}", parameter_index + 1);
      }
      index++;
    }
    count = index;
    regex = new RegExp(regex_string);
    matches = regex.exec(string);
    if (matches) {
      matches.shift();
    }
    if (!matches || (matches.length !== parameter_count)) {
      return _.range(count).map(function() {
        return '';
      });
    }
    sorted_positions = _.sortBy(_.keys(positions), function(parameter_index, format_index) {
      return parseInt(parameter_index, 10);
    });
    format_indices_to_matched_indices = {};
    for (match_index in sorted_positions) {
      parameter_index = sorted_positions[match_index];
      index = positions[parameter_index];
      if (format_indices_to_matched_indices.hasOwnProperty(index)) {
        continue;
      }
      format_indices_to_matched_indices[index] = match_index;
    }
    results = [];
    index = 0;
    while (index < count) {
      results.push(matches[format_indices_to_matched_indices[index]]);
      index++;
    }
    return results;
  };

  kb.FormattedObservable = (function() {

    function FormattedObservable(format, args) {
      var observable, observable_args;
      if (_.isArray(args)) {
        format = format;
        observable_args = args;
      } else {
        observable_args = Array.prototype.slice.call(arguments, 1);
      }
      observable = kb.utils.wrappedObservable(this, ko.dependentObservable({
        read: function() {
          var arg, _i, _len;
          args = [ko.utils.unwrapObservable(format)];
          for (_i = 0, _len = observable_args.length; _i < _len; _i++) {
            arg = observable_args[_i];
            args.push(ko.utils.unwrapObservable(arg));
          }
          return kb.toFormattedString.apply(null, args);
        },
        write: function(value) {
          var index, matches, max_count;
          matches = kb.parseFormattedString(value, ko.utils.unwrapObservable(format));
          max_count = Math.min(observable_args.length, matches.length);
          index = 0;
          while (index < max_count) {
            observable_args[index](matches[index]);
            index++;
          }
          return this;
        }
      }));
      return observable;
    }

    FormattedObservable.prototype.destroy = function() {
      return kb.utils.wrappedDestroy(this);
    };

    return FormattedObservable;

  })();

  kb.formattedObservable = function(format, args) {
    return new kb.FormattedObservable(format, Array.prototype.slice.call(arguments, 1));
  };

  /*
    knockback_localized_observable.js
    (c) 2011, 2012 Kevin Malakoff.
    Knockback.LocalizedObservable is freely distributable under the MIT license.
    See the following for full license details:
      https://github.com/kmalakoff/knockback/blob/master/LICENSE
  */


  kb.LocalizedObservable = (function() {

    LocalizedObservable.extend = Backbone.Model.extend;

    function LocalizedObservable(value_holder, options, view_model) {
      var observable, value,
        _this = this;
      this.value_holder = value_holder;
      if (options == null) {
        options = {};
      }
      this.view_model = view_model != null ? view_model : {};
      if (!this.read) {
        kb.utils.throwMissing(this, 'read');
      }
      if (!kb.locale_manager) {
        kb.utils.throwMissing(this, 'kb.locale_manager');
      }
      this.__kb || (this.__kb = {});
      this.__kb._onLocaleChange = _.bind(this._onLocaleChange, this);
      this.__kb._onChange = options.onChange;
      if (this.value_holder) {
        value = ko.utils.unwrapObservable(this.value_holder);
      }
      kb.utils.wrappedByKey(this, 'vo', ko.observable(!value ? null : this.read(value, null)));
      observable = kb.utils.wrappedObservable(this, ko.dependentObservable({
        read: function() {
          var value_observable;
          if (_this.value_holder) {
            ko.utils.unwrapObservable(_this.value_holder);
          }
          value_observable = kb.utils.wrappedByKey(_this, 'vo');
          value_observable();
          return _this.read(ko.utils.unwrapObservable(_this.value_holder));
        },
        write: function(value) {
          var value_observable;
          if (!_this.write) {
            kb.utils.throwUnexpected(_this, 'writing to read-only');
          }
          _this.write(value, ko.utils.unwrapObservable(_this.value_holder));
          value_observable = kb.utils.wrappedByKey(_this, 'vo');
          value_observable(value);
          if (_this.__kb._onChange) {
            return _this.__kb._onChange(value);
          }
        },
        owner: this.view_model
      }));
      observable.destroy = _.bind(this.destroy, this);
      observable.observedValue = _.bind(this.observedValue, this);
      observable.resetToCurrent = _.bind(this.resetToCurrent, this);
      kb.locale_manager.bind('change', this.__kb._onLocaleChange);
      if (options.hasOwnProperty('default')) {
        observable = ko.defaultWrapper(observable, options["default"]);
      }
      return observable;
    }

    LocalizedObservable.prototype.destroy = function() {
      kb.locale_manager.unbind('change', this.__kb._onLocaleChange);
      this.view_model = null;
      return kb.utils.wrappedDestroy(this);
    };

    LocalizedObservable.prototype.resetToCurrent = function() {
      var current_value, value_observable;
      value_observable = kb.utils.wrappedByKey(this, 'vo');
      value_observable(null);
      current_value = this.value_holder ? this.read(ko.utils.unwrapObservable(this.value_holder)) : null;
      return kb.utils.wrappedObservable(this)(current_value);
    };

    LocalizedObservable.prototype.observedValue = function(value) {
      if (arguments.length === 0) {
        return this.value_holder;
      }
      this.value_holder = value;
      this._onLocaleChange();
      return this;
    };

    LocalizedObservable.prototype._onLocaleChange = function() {
      var value, value_observable;
      value = this.read(ko.utils.unwrapObservable(this.value_holder));
      value_observable = kb.utils.wrappedByKey(this, 'vo');
      value_observable(value);
      if (this.__kb._onChange) {
        return this.__kb._onChange(value);
      }
    };

    return LocalizedObservable;

  })();

  kb.localizedObservable = function(value, options, view_model) {
    return new kb.LocalizedObservable(value, options, view_model);
  };

  /*
    knockback_observable.js
    (c) 2012 Kevin Malakoff.
    Knockback.Observable is freely distributable under the MIT license.
    See the following for full license details:
      https://github.com/kmalakoff/knockback/blob/master/LICENSE
  */


  kb.Observable = (function() {

    function Observable(model, options, view_model) {
      var observable,
        _this = this;
      this.view_model = view_model != null ? view_model : {};
      if (!options) {
        kb.utils.throwMissing(this, 'options');
      }
      this.key = _.isString(options) || ko.isObservable(options) ? options : options.key;
      if (!this.key) {
        kb.utils.throwMissing(this, 'key');
      }
      this.args = options.args;
      this.read = options.read;
      this.write = options.write;
      kb.utils.wrappedByKey(this, 'vo', ko.observable(null));
      observable = kb.utils.wrappedObservable(this, ko.dependentObservable({
        read: function() {
          var arg, args, current_model, new_value, _i, _len, _ref;
          args = [ko.utils.unwrapObservable(_this.key)];
          if (_this.args) {
            if (_.isArray(_this.args)) {
              _ref = _this.args;
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                arg = _ref[_i];
                args.push(ko.utils.unwrapObservable(arg));
              }
            } else {
              args.push(ko.utils.unwrapObservable(_this.args));
            }
          }
          observable = kb.utils.wrappedObservable(_this);
          current_model = observable ? kb.utils.wrappedObject(observable) : null;
          if (current_model) {
            new_value = _this.read ? _this.read.apply(_this.view_model, args) : current_model.get.apply(current_model, args);
            _this.update(new_value);
          }
          return ko.utils.unwrapObservable(kb.utils.wrappedByKey(_this, 'vo')());
        },
        write: function(new_value) {
          var arg, args, current_model, set_info, _i, _len, _ref;
          set_info = {};
          set_info[ko.utils.unwrapObservable(_this.key)] = new_value;
          args = _this.write ? [new_value] : [set_info];
          if (_this.args) {
            if (_.isArray(_this.args)) {
              _ref = _this.args;
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                arg = _ref[_i];
                args.push(ko.utils.unwrapObservable(arg));
              }
            } else {
              args.push(ko.utils.unwrapObservable(_this.args));
            }
          }
          current_model = kb.utils.wrappedObject(kb.utils.wrappedObservable(_this));
          if (current_model) {
            if (_this.write) {
              _this.write.apply(_this.view_model, args);
            } else {
              current_model.set.apply(current_model, args);
            }
          }
          return _this.update(new_value);
        },
        owner: this.view_model
      }));
      kb.utils.wrappedStore(observable, options.store);
      kb.utils.wrappedFactory(observable, options.factory);
      kb.utils.wrappedPath(observable, kb.utils.pathJoin(options.path, this.key));
      observable.valueType = _.bind(this.valueType, this);
      observable.model = _.bind(this.model, this);
      observable.update = _.bind(this.update, this);
      observable.destroy = _.bind(this.destroy, this);
      kb.ModelObservable.useOptionsOrCreate(options, model, this, {
        model: _.bind(this.model, this),
        update: _.bind(this.update, this),
        key: this.key
      });
      if (options.localizer) {
        observable = new options.localizer(observable);
      }
      if (options.hasOwnProperty('default')) {
        observable = kb.defaultWrapper(observable, options["default"]);
      }
      return observable;
    }

    Observable.prototype.destroy = function() {
      var store, value_observable;
      value_observable = kb.utils.wrappedByKey(this, 'vo');
      store = kb.utils.wrappedStore(kb.utils.wrappedObservable(this));
      if (store) {
        store.releaseObservable(value_observable());
      } else {
        kb.utils.release(value_observable());
      }
      kb.utils.wrappedByKey(this, 'vo', null);
      return kb.utils.wrappedDestroy(this);
    };

    Observable.prototype.model = function(new_model) {
      var model, observable;
      observable = kb.utils.wrappedObservable(this);
      model = kb.utils.wrappedObject(observable);
      if ((arguments.length === 0) || (model === new_model)) {
        return model;
      }
      kb.utils.wrappedObject(observable, new_model);
      if (!new_model) {
        return;
      }
      return this.update();
    };

    Observable.prototype.update = function(new_value) {
      var model, new_type, observable, value;
      observable = kb.utils.wrappedObservable(this);
      model = kb.utils.wrappedObject(observable);
      value = kb.utils.wrappedByKey(this, 'vo')();
      if (model && !arguments.length) {
        new_value = model.get(ko.utils.unwrapObservable(this.key));
      }
      new_type = kb.utils.valueType(new_value);
      if (_.isUndefined(this.value_type) || (this.value_type !== new_type && new_type !== kb.TYPE_UNKNOWN)) {
        return this._updateValueObservable(new_value);
      } else if (this.value_type === kb.TYPE_MODEL) {
        if (typeof value.model === 'function') {
          if (value.model() !== new_value) {
            return value.model(new_value);
          }
        } else if (kb.utils.wrappedObject(value) !== new_value) {
          return this._updateValueObservable(new_value);
        }
      } else if (this.value_type === kb.TYPE_COLLECTION) {
        if (value.collection() !== new_value) {
          return value.collection(new_value);
        }
      } else {
        if (value() !== new_value) {
          return value(new_value);
        }
      }
    };

    Observable.prototype.valueType = function() {
      var model, new_value;
      model = kb.utils.wrappedObject(kb.utils.wrappedObservable(this));
      new_value = model ? model.get(this.key) : null;
      if (!this.value_type) {
        this._updateValueObservable(new_value);
      }
      return this.value_type;
    };

    Observable.prototype._updateValueObservable = function(new_value) {
      var observable, store, value, value_observable;
      observable = kb.utils.wrappedObservable(this);
      store = kb.utils.wrappedStore(observable);
      if (store) {
        value = store.findOrCreateObservable(new_value, kb.utils.wrappedPath(observable), kb.utils.wrappedFactory(observable));
      } else {
        value = kb.Factory.createDefault(new_value, {
          path: kb.utils.wrappedPath(observable)
        });
      }
      if (!ko.isObservable(value)) {
        this.value_type = kb.TYPE_MODEL;
      } else if (kb.utils.observableInstanceOf(value, kb.CollectionObservable)) {
        this.value_type = kb.TYPE_COLLECTION;
      } else {
        this.value_type = kb.TYPE_SIMPLE;
      }
      value_observable = kb.utils.wrappedByKey(this, 'vo');
      if (store) {
        store.releaseObservable(value_observable());
      } else {
        kb.utils.release(value_observable());
      }
      return value_observable(value);
    };

    return Observable;

  })();

  kb.observable = function(model, key, options) {
    return new kb.Observable(model, key, options);
  };

  /*
    knockback_observables.js
    (c) 2011, 2012 Kevin Malakoff.
    Knockback.Observables is freely distributable under the MIT license.
    See the following for full license details:
      https://github.com/kmalakoff/knockback/blob/master/LICENSE
  */


  kb.Observables = (function() {

    function Observables(model, mappings_info, view_model) {
      var key, mapping_info, model_observable, _i, _len, _ref;
      if (!model) {
        throw 'Observables: model is missing';
      }
      if (!(mappings_info && (_.isObject(mappings_info) || _.isArray(mappings_info)))) {
        throw 'Observables: mappings_info is missing';
      }
      this.__kb || (this.__kb = {});
      if (_.isArray(mappings_info)) {
        this.__kb.mappings_info = {};
        for (_i = 0, _len = mappings_info.length; _i < _len; _i++) {
          key = mappings_info[_i];
          this.__kb.mappings_info[key] = {};
        }
      } else {
        this.__kb.mappings_info = mappings_info;
      }
      this.__kb.view_model = _.isUndefined(view_model) ? this : view_model;
      model_observable = kb.utils.wrappedModelObservable(this, new kb.ModelObservable(model, this, {
        model: _.bind(this.model, this)
      }));
      _ref = this.__kb.mappings_info;
      for (key in _ref) {
        mapping_info = _ref[key];
        if (!mapping_info.hasOwnProperty('key')) {
          mapping_info.key = key;
        }
        mapping_info.model_observable = model_observable;
        this[key] = this.__kb.view_model[key] = kb.observable(model, mapping_info, this.__kb.view_model);
      }
    }

    Observables.prototype.destroy = function() {
      var key, mapping_info, _ref;
      _ref = this.__kb.mappings_info;
      for (key in _ref) {
        mapping_info = _ref[key];
        if (this[key] && this[key].__kb) {
          this[key].destroy();
        }
        this[key] = this.__kb.view_model[key] = null;
      }
      return kb.utils.wrappedDestroy(this);
    };

    Observables.prototype.setToDefault = function() {
      var key, mapping_info, _ref;
      _ref = this.__kb.mappings_info;
      for (key in _ref) {
        mapping_info = _ref[key];
        if (typeof this[key].setToDefault === 'function') {
          this[key].setToDefault();
        }
      }
      return this;
    };

    Observables.prototype.model = function(new_model) {
      var model, model_observable;
      model = kb.utils.wrappedObject(this);
      if ((arguments.length === 0) || (model === new_model)) {
        return model;
      }
      model = kb.utils.wrappedObject(this, new_model);
      if (!model) {
        return;
      }
      model_observable = kb.utils.wrappedModelObservable(this);
      if (!model_observable) {
        return new_model;
      }
      return model_observable.model(model);
    };

    return Observables;

  })();

  kb.observables = function(model, mappings_info, view_model) {
    return new kb.Observables(model, mappings_info, view_model);
  };

  /*
    knockback_triggered_observable.js
    (c) 2011, 2012 Kevin Malakoff.
    Knockback.Observable is freely distributable under the MIT license.
    See the following for full license details:
      https://github.com/kmalakoff/knockback/blob/master/LICENSE
  */


  kb.TriggeredObservable = (function() {

    function TriggeredObservable(model, event_name) {
      var observable,
        _this = this;
      this.event_name = event_name;
      if (!model) {
        kb.utils.throwMissing(this, 'model');
      }
      if (!this.event_name) {
        kb.utils.throwMissing(this, 'event_name');
      }
      kb.utils.wrappedByKey(this, 'vo', ko.observable());
      observable = kb.utils.wrappedObservable(this, ko.dependentObservable(function() {
        return kb.utils.wrappedByKey(_this, 'vo')();
      }));
      observable.destroy = _.bind(this.destroy, this);
      kb.utils.wrappedModelObservable(this, new kb.ModelObservable(model, this, {
        model: _.bind(this.model, this),
        update: _.bind(this.update, this),
        event_name: this.event_name
      }));
      return observable;
    }

    TriggeredObservable.prototype.destroy = function() {
      this.options = null;
      this.view_model = null;
      return kb.utils.wrappedDestroy(this);
    };

    TriggeredObservable.prototype.model = function(new_model) {
      var model, observable;
      observable = kb.utils.wrappedObservable(this);
      model = kb.utils.wrappedObject(observable);
      if ((arguments.length === 0) || (model === new_model)) {
        return model;
      }
      kb.utils.wrappedObject(observable, new_model);
      if (!new_model) {
        return;
      }
      return this.update();
    };

    TriggeredObservable.prototype.update = function() {
      var current_value, model, observable, value_observable;
      observable = kb.utils.wrappedObservable(this);
      value_observable = kb.utils.wrappedByKey(this, 'vo');
      current_value = value_observable();
      model = kb.utils.wrappedObject(observable);
      if (!model) {
        return;
      }
      if (current_value !== model) {
        return value_observable(model);
      } else {
        return value_observable.valueHasMutated();
      }
    };

    return TriggeredObservable;

  })();

  kb.triggeredObservable = function(model, event_name) {
    return new kb.TriggeredObservable(model, event_name);
  };

  /*
    knockback_view_model.js
    (c) 2011, 2012 Kevin Malakoff.
    Knockback.Observable is freely distributable under the MIT license.
    See the following for full license details:
      https://github.com/kmalakoff/knockback/blob/master/LICENSE
  */


  kb.ViewModel = (function(_super) {

    __extends(ViewModel, _super);

    function ViewModel(model, options) {
      var bb_model, factory, key, keys, model_observable, observable_options, path, store, vm_key, _i, _len, _ref;
      if (options == null) {
        options = {};
      }
      ViewModel.__super__.constructor.apply(this, arguments);
      if (kb.statistics) {
        kb.statistics.register('kb.ViewModel', this);
      }
      store = kb.Store.useOptionsOrCreate(options, model, this);
      factory = kb.utils.wrappedFactory(this, new kb.Factory(options.factory));
      path = kb.utils.wrappedPath(this, options.path);
      if (options.mappings) {
        factory.addPathMappings(options.mappings);
      }
      this.__kb.internals = options.internals;
      this.__kb.requires = options.requires;
      model_observable = kb.utils.wrappedModelObservable(this, new kb.ModelObservable(model, this, {
        model: _.bind(this.model, this)
      }));
      bb_model = model_observable.model();
      if (bb_model) {
        keys = _.keys(bb_model.attributes);
      }
      if (this.__kb.internals) {
        keys = keys ? _.union(keys, this.__kb.internals) : this.__kb.internals;
      }
      if (this.__kb.requires) {
        keys = keys ? _.union(keys, this.__kb.requires) : this.__kb.requires;
      }
      this.__kb.keys = keys || [];
      observable_options = {
        store: store,
        factory: factory,
        path: path,
        model_observable: model_observable
      };
      _ref = this.__kb.keys;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        vm_key = this.__kb.internals && _.contains(this.__kb.internals, key) ? '_' + key : key;
        observable_options.key = key;
        this[vm_key] = kb.observable(model, observable_options, this);
      }
    }

    ViewModel.prototype.__destroy = function() {
      kb.utils.release(this, true);
      kb.utils.wrappedDestroy(this);
      ViewModel.__super__.__destroy.apply(this, arguments);
      if (kb.statistics) {
        return kb.statistics.unregister('kb.ViewModel', this);
      }
    };

    ViewModel.prototype.model = function(new_model) {
      var key, missing, model, model_observable, observable_options, vm_key, _i, _len;
      model = kb.utils.wrappedObject(this);
      if ((arguments.length === 0) || (model === new_model)) {
        return model;
      }
      model = kb.utils.wrappedObject(this, new_model);
      if (!model) {
        return;
      }
      model_observable = kb.utils.wrappedModelObservable(this);
      if (!model_observable) {
        return new_model;
      }
      model_observable.model(model);
      missing = _.difference(this.__kb.keys, _.keys(model.attributes));
      if (!missing) {
        return;
      }
      observable_options = {
        store: kb.utils.wrappedStore(this),
        factory: kb.utils.wrappedFactory(this),
        path: kb.utils.wrappedPath(this),
        model_observable: kb.utils.wrappedModelObservable(this)
      };
      for (_i = 0, _len = missing.length; _i < _len; _i++) {
        key = missing[_i];
        this.__kb.keys.push(key);
        vm_key = this.__kb.internals && _.contains(this.__kb.internals, key) ? '_' + key : key;
        observable_options.key = key;
        this[vm_key] = kb.observable(model, observable_options, this);
      }
      return new_model;
    };

    return ViewModel;

  })(kb.RefCountable);

  kb.viewModel = function(model, options) {
    return new kb.ViewModel(model, options);
  };

}).call(this);
