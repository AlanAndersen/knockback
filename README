    __ __                  __   __               __       _
   / //_/____  ____  _____/ /__/ /_  ____ ______/ /__    (_)____
  / ,<  / __ \/ __ \/ ___/ //_/ __ \/ __ `/ ___/ //_/   / / ___/
 / /| |/ / / / /_/ / /__/ ,< / /_/ / /_/ / /__/ ,< _   / (__  )
/_/ |_/_/ /_/\____/\___/_/|_/_.___/\__,_/\___/_/|_(_)_/ /____/
                                                   /___/

Knockback.js provides Knockout.js magic for Backbone.js Models and Collections.

You can get the library here:
  - Development version: https://github.com/kmalakoff/knockback/raw/master/knockback.js
  - Production version: https://github.com/kmalakoff/knockback/raw/master/knockback.min.js

You also will need to use my slightly modified copies of Knockout until the changes are merged into the main branch:
  - Development version: https://github.com/kmalakoff/knockback/raw/master/knockout-1.2.1-kmalakoff.js
  - Production version: https://github.com/kmalakoff/knockback/raw/master/knockout-1.2.1.debug-kmalakoff.min.js

If anyone wants to port this to Knockout 1.3 beta, please do and let me know! You can find my changes here: https://github.com/kmalakoff/knockout/tree/forceRefresh


When I was evaluating client-side frameworks, I liked lots of the pieces, but wanted to "mix and match" the best features. I started with Backbone.js (http://documentcloud.github.com/backbone/) and really loved the Models and Collections, and used Brunch (http://brunch.io/) to get me up and running quickly.

After a while, I found the view coding too slow so I wrote Mixin.js (https://github.com/kmalakoff/mixin) to extract out reusable aspects of my views. When I was looking for my next productivity increase, an ex-work colleague suggested Sproutcore (http://www.sproutcore.com/), but at the time, it wasn't yet micro-frameworky enough meaning I would need to learn something big and "to throw the baby out with the bathwater" as they say (it is hard to give up Backbone models and collections!). Then, I discovered Knockout (http://knockoutjs.com/) and knew it was for me!

Knockout provided just the right building blocks for a layer between my templates and data. As I used it more, I built additional functionality like Backbone.ModelRefs (https://github.com/kmalakoff/backbone-modelref) for lazy model loading, localization helpers for truly dynamic views, and most recently, an easier way to sync collections and their model's view models.

So here it is...the refactored and shareable version of my Backbone bindings for Knockout: Knockback.js

Enjoy!

Kevin


PS: check out the jsFiddle that demonstrates dynamic localization: http://jsfiddle.net/kmalakoff/QSkpv/

An Example:
**********

  The view model:

    class ContactViewModel
      constructor: (model) ->
        new kb.ModelAttributeObservables(model, {
          name:     {keypath:'name'}
          email:    {keypath:'email', write: true, default: 'your.name@yourplace.com'}
          date:     {keypath:'date', write: true, localizer: (value) => return new LocalizedObservable_LongDate(value)}
        }, this)

  The HTML:

    <label>Name: </label><input data-bind="value: name" />
    <label>Email: </label><input data-bind="value: email" />
    <label>Birthdate: </label><input data-bind="value: date" />

  And...engage:

    view_model = new ContactViewModel(collection.get('some_id'))
    ko.applyBindings(view_model)

And now when you type in the input boxes, the values are properly transferred to the model and the dates are even localized!

Of course, this is just a simple example, but hopefully you get the picture. For a more advanced version, look at test/interactive/test.html or http://jsfiddle.net/kmalakoff/QSkpv/.

****************
The library includes the following classes:

  1) Knockback.ModelAttributeObservables and Knockback.ModelAttributeObservable - these are the foundations for watching model attributes for one and two-way changes. The pluralized form provides a short-hand for multiple attributes like in the above example.

  Note 1: you can watch a non-BackboneModel as long as it: a) mixes in Backbone.Events and triggers 'change' and/or "change:#{attribute_name}" events and b) implements "get: (attribute_name) -> return something". This simplified Backbone.Model API is the same interface as is needed for your implementation of Knockback.locale_manager:

    new kb.ModelAttributeObservables(Knockback.locale_manager, {
      label_title_new:    { keypath: 'label_title_new' },
      label_button_new:   { keypath: 'label_button_new' },
      label_name:         { keypath: 'label_name' },
      label_email:        { keypath: 'label_email' },
      label_date:         { keypath: 'label_date' }
    }, view_model)

  Note 2: you can provide custom read and write methods to provide custom formatting to the attributes just like in Knockout.

    new kb.ModelAttributeObservable(model, {
      keypath:'number'
      read: -> return "#: #{model.get('number')}"
      write: (value) -> model.set({number: value.substring(3)})
    }, this)

  Note 3: you can provide a localizer (see Knockback.LocalizedObservable) to both provide read and write localization for an attribute.

    new kb.ModelAttributeObservables(model, {
      date:     {keypath:'date', write: true, localizer: (value) => return new LocalizedObservable_LongDate(value)}
    }, this)

  Note 4: you can also watch a Backbone.ModelRef instead of a Backbone.Model. What is a Backbone.ModelRef do you ask? It is the combination of a collection and a model id that tells you when it is loaded and unloaded (https://github.com/kmalakoff/backbone-modelref). That way, you can start rendering views on a page while the models are loading. If the model unloads, the default behavior is to retain the last value, but you can force a refresh on unload using attribute_observable.forceRefresh():

  2) Knockback.CollectionSync - this basically takes a ko.observableArray and makes sure it stays in sync and sorted with a collection. You need to at minimum provide a "viewModelCreate: (model) -> return new myViewModel(model)" function which can return an instance of a class or can be a plain old Javascript object. The important thing is that the view model you provide should be unique per instance of your model or else the "behavior is not guaranteed".

    new Knockback.CollectionSync(collection, view_models_array, {
      viewModelCreate:    (model) -> return new ContactViewModel(model)
      viewModelDestroy:   (view_model) -> view_model.destroy()
    })

  Note 1: you can either have the collection sort for you (eg. using a Backbone.Collection "comparator") or you can provide your own sorting methods that are decoupled from the collection like:

    collection_sync = new Knockback.CollectionSync(collection, view_models_array, {
      sort_attribute:     'name' # optimization to only refresh when this attribute changes
      sortedIndex:        (models, model) -> _.sortedIndex(models, model, (test) -> test.get('name'))
    })

  Note 2: Collections cache some information on the view model and if you have a view model and want to get access to it, use the following helpers:
    a) kb.vmModel - to get the model for the view model
    b) kb.vmElement - to get the rendered element from Knockout.

  Note 3: there are some other helpers for collection sync view models that you may find useful:

    a) modelByViewModel: (view_model) ->
    b) viewModelByModel: (model) ->
    c) elementByModel: (model) ->
    d) eachViewModel: (iterator) ->

  3) Knockback.LocalizedObservable - this is the most tricky to implement (look in the examples_lib/localized_observables.coffee file for examples). Basically, a value is stored inside this class and is manually synced by a Knockback.ModelAttributeObservable whenever the model attribute changes since it can point to a new value instance for the same attribute. Here's an example of a read only one:

  class LocalizedObservable_LocalizedString extends kb.LocalizedObservable
    constructor: (value, options={}, view_model) ->
      return super(value, _.extend(options, {
        read: =>
          localized_string = @getObservedValue(); return '' if not localized_string
          return if (localized_string.string_id) then Knockback.locale_manager.get(localized_string.string_id) else ''
      }), view_model)

    Note 1: this looks like it returns an instance but it actually returns a ko.dependentObservable from super. Don't get caught out!

    Note 2: if you use these localization helpers, you need to implement a Knockback.locale_manager.  As mentioned in 1) Note 1....you can watch a non-BackboneModel as long as it: a) mixes in Backbone.Events and triggers 'change' events and b) implements "get: (attribute_name) -> " and which is a minimal Backbone.Model interface...this is just what a Backbone.locale_manager is. Pretty clever, eh?


Final notes:

  a) Everything uses a new/destroy lifecycle. You need to destroy everything you create to ensure memory is cleaned up correctly. Some of my examples leave that out rigorous cleanup for understandability, but please don't forget!

  b) Naming conventions. The library is based on the following: i) Classes are CamelCase, ii) functions are sortaCamelCased, iii) properties are written_with_underscores, and constants are BIG_AND_NOTICABLE.

  c) The Knockback and kb namespaces are aliased so you can be brief or not...your choice. In other words: Knockback.CollectionSync and kb.CollectionSync point to the same constructor.

  d) Knockback.ModelAttributeObservable and Knockback.LocalizedObservable actually return a ko.dependentObservable with a bound destroy method on it. It you want to subclass your own, look at the source files (like Knockback.ModelAttributeObservable) because a little bit of a Coffeescript dance is required to return the right thing from your constructor!


In addition to the examples in the test folder (https://github.com/kmalakoff/knockback/blob/master/test), you can look at the examples_lib folder for a sample Knockback.locale_manager, a localized string, and some examples of localized observables.
