    __ __                  __   __               __       _
   / //_/____  ____  _____/ /__/ /_  ____ ______/ /__    (_)____
  / ,<  / __ \/ __ \/ ___/ //_/ __ \/ __ `/ ___/ //_/   / / ___/
 / /| |/ / / / /_/ / /__/ ,< / /_/ / /_/ / /__/ ,< _   / (__  )
/_/ |_/_/ /_/\____/\___/_/|_/_.___/\__,_/\___/_/|_(_)_/ /____/
                                                   /___/

Knockback.js provides Knockout.js magic for Backbone.js Models and Collections.

You can get the library here:
  - Development version: https://github.com/kmalakoff/knockback/raw/master/knockback.js
  - Production version: https://github.com/kmalakoff/knockback/raw/master/knockback.min.js

You also will need to use my slightly modified copies of Knockout until the changes are merged into the main branch:
  - Development version: https://github.com/kmalakoff/knockback/raw/master/knockout-1.2.1-kmalakoff.js
  - Production version: https://github.com/kmalakoff/knockback/raw/master/knockout-1.2.1.debug-kmalakoff.min.js

If anyone want to port this to Knockout 1.3 beta, please do and let me know!.


When I was evaluating client-side frameworks, I liked lots of the pieces, but wanted to "mix and match" the best features. I started with Backbone.js (http://documentcloud.github.com/backbone/) and really loved the Models and Collections, and used Brunch (http://brunch.io/) to get me up and running quickly.

After a while, I found the view coding too slow so I wrote Mixin.js (https://github.com/kmalakoff/mixin) to extract out reusable aspects of my views. When I was looking for my next productivity increase, a work colleague suggested Sproutcore (http://www.sproutcore.com/), but it wasn't yet micro-frameworky enough (but shows a lot of potential!) meaning I would need to learn something huge and "to throw the baby out with the bathwater" as they say. Then I discovered Knockout (http://knockoutjs.com/) and knew it was for me!

Knockout provided just the building blocks for a layer between my templates and data. As i used it more, I build additional functionality like Backbone.ModelRefs (https://github.com/kmalakoff/backbone-modelref) for lazy model loading, Localization helpers for truly dynamic views, and most recently an easier way to sync collections and their model's view models.

So here is the refactored and shareable version of my Backbone bindings for Knockout: Knockback.js

Enjoy!

Kevin


PS: check out the jsFiddle I set up to demonstrate localization: http://jsfiddle.net/kmalakoff/QSkpv/

An Example:
**********

  The view model:

    class ContactViewModel
      constructor: (model) ->
        new kb.ModelAttributeObservables(model, {
          name:     {keypath:'name'}
          number:   {keypath:'number', read_write: true}
          date:     {keypath:'date', read_write: true, localizer: (value) => return new LocalizedObservable_LongDate(value)}
        }, this)

  The HTML:

    <label>Name: </label><input data-bind="value: name" />
    <label>Email: </label><input data-bind="value: email" />
    <label>Birthdate: </label><input data-bind="value: date" />

  Engage:

    view_model = new ContactViewModel(collection.get('some_id'))
    ko.applyBindings(view_model)

And now when you type in the input boxes, the values are properly transferred to the model and the dates are even localized!

Of course, this is just a simple example, but hopefully you get the picture. For a more advanced version, look at test/interactive/test.html.

****************
The library is composed of the following classes:

  1) Knockback.ModelAttributeObservables and Knockback.ModelAttributeObservable - these are the foundations for watching model attributes for one or two-way changes. The pluralized form provides a short-hand like above.

  Note 1: you can watch a non-BackboneModel as long as it: a) mixes in Backbone.Events and triggers 'change' events and b) implements "get: (attribute_name) -> ".

    new kb.ModelAttributeObservables(Knockback.locale_manager, {
      label_title_new:    { keypath: 'label_title_new' },
      label_button_new:   { keypath: 'label_button_new' },
      label_name:         { keypath: 'label_name' },
      label_email:        { keypath: 'label_email' },
      label_date:         { keypath: 'label_date' }
    }, view_model);

  Note 2: you can also watch a Backbone.ModelRef instead of a Backbone.Model. What is a Backbone.ModelRef do you ask? It is the combination of a collection and a model id that tells you when it is loaded and unloaded. That way, you can start rendering views on a page while the models are loading.

  2) Knockback.CollectionSync - this basically takes a ko.observableArray and makes sure it stays in sync and sorted with a collection. You need to at minimum provide a viewModelCreate function which can return an instance of a class or a plain old Javascript object. The important thing is that they should be unique per instance of your model or else the "behavior is not guaranteed".

    new Knockback.CollectionSync(collection, view_models_array, {
      viewModelCreate:    (model) -> return new ContactViewModel(model)
      viewModelDestroy:   (view_model) -> view_model.destroy()
    })

  Note 1: you can either have the collection sort for you (eg. using a "comparator") or you can provide your own sorting methods that are decoupled from the collection like:

    collection_sync = new Knockback.CollectionSync(collection, view_models_array, {
      sort_attribute:     'name'
      sortedIndex:        (models, model) -> _.sortedIndex(models, model, (test) -> test.get('name'))
    })

  Note 2: Collections cache some information on the view model and if you want to get at it, use the following helpers:
    a) kb.vmModel - to get the model for the view model
    b) kb.vmElement - to get the rendered element from Knockout.

  3) Knockback.LocalizedObservable - this is the most tricky. Basically, a value is stored inside this class and manually synced by a Knockback.ModelAttributeObservable whenever the model attribute changes since it can point to a new instance. Here's an example of a read only one:

  class LocalizedObservable_LocalizedString extends kb.LocalizedObservable
    constructor: (value, options={}, view_model) ->
      return super(value, _.extend(options, {
        read: =>
          localized_string = @getObservedValue(); return '' if not localized_string
          return if (localized_string.string_id) then Knockback.locale_manager.get(localized_string.string_id) else ''
      }), view_model)

    Note 1: this looks like it returns an instance but it actually returns a ko.dependentObservable from super. Don't get caught out!

    Note 2: if you use localization, you need to implement a Knockback.locale_manager.  As mentioned in 1) Note 1....you can watch a non-BackboneModel as long as it: a) mixes in Backbone.Events and triggers 'change' events and b) implements "get: (attribute_name) -> " and this is just what a LocalManager is. Pretty clever, eh?


Final notes:

  a) Everything uses a new/destroy lifecycle. You need to destroy everything your create to ensure they are cleaned up correctly. Some of my examples leave that out for readability, but please don't forget.

  b) Naming conventions. The library is based on the following: i) Classes are CamelCase, ii) functions are sortaCamelCased, iii) properties are written_with_underscores, and constants are BIG_AND_NOTICABLE.

  c) The Knockback and kb namespaces are aliased so you can be brief or not...your choice.

  d) Knockback.ModelAttributeObservable and Knockback.LocalizedObservable actually return a ko.dependentObservable with a bound destroy method on it. It you want to subclass your own, look at the source files because a little bot of a dance is required!


Also, you can look at the examples_lib folder for a sample Knockback.locale_manager, a localized string, and some examples of localized observables.


Until there is more documentation, please look at the provided test for sample code and a better idea of the API:
  - https://github.com/kmalakoff/knockback/blob/master/test
