// Generated by CoffeeScript 1.3.1
/*
  knockback_observable.js
  (c) 2011 Kevin Malakoff.
  Knockback.Observable is freely distributable under the MIT license.
  See the following for full license details:
    https://github.com/kmalakoff/knockback/blob/master/LICENSE
*/

Knockback.Observable = (function() {

  Observable.name = 'Observable';

  function Observable(model, options, view_model) {
    var observable,
      _this = this;
    this.model = model;
    this.options = options;
    this.view_model = view_model != null ? view_model : {};
    if (!this.model) {
      throw new Error('Observable: model is missing');
    }
    if (!this.options) {
      throw new Error('Observable: options is missing');
    }
    if (_.isString(this.options) || ko.isObservable(this.options)) {
      this.options = {
        key: this.options
      };
    }
    if (!this.options.key) {
      throw new Error('Observable: options.key is missing');
    }
    this.__kb = {};
    this.__kb._onModelChange = _.bind(this._onModelChange, this);
    this.__kb._onModelLoaded = _.bind(this._onModelLoaded, this);
    this.__kb._onModelUnloaded = _.bind(this._onModelUnloaded, this);
    if (this.options.hasOwnProperty('write') && _.isBoolean(this.options.write)) {
      this.options = _.clone(this.options);
      this.options.read_only = !this.options.write;
    }
    if (Backbone.ModelRef && (this.model instanceof Backbone.ModelRef)) {
      this.model_ref = this.model;
      this.model_ref.retain();
      this.model_ref.bind('loaded', this.__kb._onModelLoaded);
      this.model_ref.bind('unloaded', this.__kb._onModelUnloaded);
      this.model = this.model_ref.getModel();
    }
    this.__kb.value_observable = ko.observable();
    if (this.options.localizer) {
      this.__kb.localizer = new this.options.localizer(this._getCurrentValue());
    }
    observable = kb.utils.wrappedObservable(this, ko.dependentObservable({
      read: _.bind(this._onGetValue, this),
      write: this.options.read_only ? (function() {
        throw new Error("Knockback.Observable: " + _this.options.key + " is read only");
      }) : _.bind(this._onSetValue, this),
      owner: this.view_model
    }));
    observable.destroy = _.bind(this.destroy, this);
    observable.setToDefault = _.bind(this.setToDefault, this);
    if (!this.model_ref || this.model_ref.isLoaded()) {
      this.model.bind('change', this.__kb._onModelChange);
    }
    return observable;
  }

  Observable.prototype.destroy = function() {
    this.__kb.value_observable = null;
    kb.utils.wrappedObservable(this).dispose();
    kb.utils.wrappedObservable(this, null);
    if (this.model) {
      this.__kb._onModelUnloaded(this.model);
    }
    if (this.model_ref) {
      this.model_ref.unbind('loaded', this.__kb._onModelLoaded);
      this.model_ref.unbind('unloaded', this.__kb._onModelUnloaded);
      this.model_ref.release();
      this.model_ref = null;
    }
    this.options = null;
    this.view_model = null;
    return this.__kb = null;
  };

  Observable.prototype.setToDefault = function() {
    var value;
    value = this._getDefaultValue();
    if (this.__kb.localizer) {
      this.__kb.localizer.observedValue(value);
      value = this.__kb.localizer();
    }
    return this.__kb.value_observable(value);
  };

  Observable.prototype._getDefaultValue = function() {
    if (!this.options.hasOwnProperty('default')) {
      return '';
    }
    if (typeof this.options["default"] === 'function') {
      return this.options["default"]();
    } else {
      return this.options["default"];
    }
  };

  Observable.prototype._getCurrentValue = function() {
    var arg, args, key, _i, _len, _ref;
    if (!this.model) {
      return this._getDefaultValue();
    }
    key = ko.utils.unwrapObservable(this.options.key);
    args = [key];
    if (!_.isUndefined(this.options.args)) {
      if (_.isArray(this.options.args)) {
        _ref = this.options.args;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          arg = _ref[_i];
          args.push(ko.utils.unwrapObservable(arg));
        }
      } else {
        args.push(ko.utils.unwrapObservable(this.options.args));
      }
    }
    if (this.options.read) {
      return this.options.read.apply(this.view_model, args);
    } else {
      return this.model.get.apply(this.model, args);
    }
  };

  Observable.prototype._onGetValue = function() {
    var arg, value, _i, _len, _ref;
    this.__kb.value_observable();
    ko.utils.unwrapObservable(this.options.key);
    if (!_.isUndefined(this.options.args)) {
      if (_.isArray(this.options.args)) {
        _ref = this.options.args;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          arg = _ref[_i];
          ko.utils.unwrapObservable(arg);
        }
      } else {
        ko.utils.unwrapObservable(this.options.args);
      }
    }
    value = this._getCurrentValue();
    if (this.__kb.localizer) {
      this.__kb.localizer.observedValue(value);
      value = this.__kb.localizer();
    }
    return value;
  };

  Observable.prototype._onSetValue = function(value) {
    var arg, args, set_info, _i, _len, _ref;
    if (this.__kb.localizer) {
      this.__kb.localizer(value);
      value = this.__kb.localizer.observedValue();
    }
    if (this.model) {
      set_info = {};
      set_info[ko.utils.unwrapObservable(this.options.key)] = value;
      args = typeof this.options.write === 'function' ? [value] : [set_info];
      if (!_.isUndefined(this.options.args)) {
        if (_.isArray(this.options.args)) {
          _ref = this.options.args;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            arg = _ref[_i];
            args.push(ko.utils.unwrapObservable(arg));
          }
        } else {
          args.push(ko.utils.unwrapObservable(this.options.args));
        }
      }
      if (typeof this.options.write === 'function') {
        this.options.write.apply(this.view_model, args);
      } else {
        this.model.set.apply(this.model, args);
      }
    }
    if (this.__kb.localizer) {
      return this.__kb.value_observable(this.__kb.localizer());
    } else {
      return this.__kb.value_observable(value);
    }
  };

  Observable.prototype._modelBind = function(model) {
    if (!model) {
      return;
    }
    model.bind('change', this.__kb._onModelChange);
    if (Backbone.RelationalModel && (model instanceof Backbone.RelationalModel)) {
      model.bind('add', this.__kb._onModelChange);
      model.bind('remove', this.__kb._onModelChange);
      return model.bind('update', this.__kb._onModelChange);
    }
  };

  Observable.prototype._modelUnbind = function(model) {
    if (!model) {
      return;
    }
    model.unbind('change', this.__kb._onModelChange);
    if (Backbone.RelationalModel && (model instanceof Backbone.RelationalModel)) {
      model.unbind('add', this.__kb._onModelChange);
      model.unbind('remove', this.__kb._onModelChange);
      return model.unbind('update', this.__kb._onModelChange);
    }
  };

  Observable.prototype._onModelLoaded = function(model) {
    this.model = model;
    this._modelBind(model);
    return this._updateValue();
  };

  Observable.prototype._onModelUnloaded = function(model) {
    if (this.__kb.localizer && this.__kb.localizer.destroy) {
      this.__kb.localizer.destroy();
      this.__kb.localizer = null;
    }
    this._modelUnbind(model);
    return this.model = null;
  };

  Observable.prototype._onModelChange = function() {
    if ((this.model && this.model.hasChanged) && !this.model.hasChanged(ko.utils.unwrapObservable(this.options.key))) {
      return;
    }
    return this._updateValue();
  };

  Observable.prototype._updateValue = function() {
    var value;
    value = this._getCurrentValue();
    if (this.__kb.localizer) {
      this.__kb.localizer.observedValue(value);
      value = this.__kb.localizer();
    }
    return this.__kb.value_observable(value);
  };

  return Observable;

})();

Knockback.observable = function(model, options, view_model) {
  return new Knockback.Observable(model, options, view_model);
};
