// Generated by CoffeeScript 1.3.1
/*
  knockback_view_model.js
  (c) 2011 Kevin Malakoff.
  Knockback.Observable is freely distributable under the MIT license.
  See the following for full license details:
    https://github.com/kmalakoff/knockback/blob/master/LICENSE
*/

var __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

Knockback.ViewModel_RCBase = (function(_super) {

  __extends(ViewModel_RCBase, _super);

  ViewModel_RCBase.name = 'ViewModel_RCBase';

  function ViewModel_RCBase() {
    return ViewModel_RCBase.__super__.constructor.apply(this, arguments);
  }

  ViewModel_RCBase.prototype.__destroy = function() {
    var key, value, _results;
    _results = [];
    for (key in this) {
      value = this[key];
      if (!value || (key === '__kb')) {
        continue;
      }
      if (kb.utils.release(value)) {
        _results.push(this[key] = null);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  return ViewModel_RCBase;

})(Knockback.RefCountable);

Knockback.ViewModel = (function(_super) {

  __extends(ViewModel, _super);

  ViewModel.name = 'ViewModel';

  function ViewModel(model, options) {
    var key, missing, _i, _len;
    if (options == null) {
      options = {};
    }
    ViewModel.__super__.constructor.apply(this, arguments);
    if (Knockback.stats_on) {
      kb.stats.view_models++;
    }
    if (!options.store_skip_resolve) {
      kb.Store.resolveFromOptions(options, this);
    }
    if (options.store) {
      this.__kb.store = options.store;
    } else {
      this.__kb.store = new kb.Store();
      this.__kb.store_is_owned = true;
    }
    this.__kb._onModelChange = _.bind(this._onModelChange, this);
    this.__kb._onModelLoaded = _.bind(this._onModelLoaded, this);
    this.__kb._onModelUnloaded = _.bind(this._onModelUnloaded, this);
    this.__kb.internals = options.internals;
    this.__kb.requires = options.requires;
    this.__kb.children = options.children;
    this.__kb.create = options.create;
    this.__kb.read_only = options.read_only;
    kb.utils.wrappedModel(this, model);
    if (Backbone.ModelRef && (model instanceof Backbone.ModelRef)) {
      this.__kb.model_ref = model;
      this.__kb.model_ref.retain();
      kb.utils.wrappedModel(this, this.__kb.model_ref.getModel());
      this.__kb.model_ref.bind('loaded', this.__kb._onModelLoaded);
      this.__kb.model_ref.bind('unloaded', this.__kb._onModelUnloaded);
    }
    if (this.__kb.model) {
      this._onModelLoaded(this.__kb.model);
    }
    if (!this.__kb.internals && !this.__kb.requires) {
      return this;
    }
    missing = _.union((this.__kb.internals ? this.__kb.internals : []), (this.__kb.requires ? this.__kb.requires : []));
    if (!this.__kb.model_ref || this.__kb.model_ref.isLoaded()) {
      missing = _.difference(missing, _.keys(this.__kb.model.attributes));
    }
    for (_i = 0, _len = missing.length; _i < _len; _i++) {
      key = missing[_i];
      this._updateAttributeConnector(this.__kb.model, key);
    }
  }

  ViewModel.prototype.__destroy = function() {
    var model;
    model = this.__kb.model;
    kb.utils.wrappedModel(this, null);
    this._modelUnbind(model);
    if (this.__kb.store_is_owned) {
      this.__kb.store.destroy();
    }
    this.__kb.store = null;
    ViewModel.__super__.__destroy.apply(this, arguments);
    if (Knockback.stats_on) {
      return kb.stats.view_models--;
    }
  };

  ViewModel.prototype.model = function(new_model) {
    var model;
    model = kb.utils.wrappedModel(this);
    if (arguments.length === 0) {
      return model;
    }
    if (new_model === model) {
      return;
    }
    if (model) {
      this._onModelUnloaded(model);
    }
    if (new_model) {
      return this._onModelLoaded(new_model);
    }
  };

  ViewModel.prototype._modelBind = function(model) {
    if (!model) {
      return;
    }
    model.bind('change', this.__kb._onModelChange);
    if (Backbone.RelationalModel && (model instanceof Backbone.RelationalModel)) {
      model.bind('add', this.__kb._onModelChange);
      model.bind('remove', this.__kb._onModelChange);
      return model.bind('update', this.__kb._onModelChange);
    }
  };

  ViewModel.prototype._modelUnbind = function(model) {
    if (!model) {
      return;
    }
    model.unbind('change', this.__kb._onModelChange);
    if (Backbone.RelationalModel && (model instanceof Backbone.RelationalModel)) {
      model.unbind('add', this.__kb._onModelChange);
      model.unbind('remove', this.__kb._onModelChange);
      return model.unbind('update', this.__kb._onModelChange);
    }
  };

  ViewModel.prototype._onModelLoaded = function(model) {
    var key, _results;
    kb.utils.wrappedModel(this, model);
    this._modelBind(model);
    _results = [];
    for (key in this.__kb.model.attributes) {
      _results.push(this._updateAttributeConnector(this.__kb.model, key));
    }
    return _results;
  };

  ViewModel.prototype._onModelUnloaded = function(model) {
    var key, _results;
    this._modelUnbind(model);
    kb.utils.wrappedModel(this, null);
    _results = [];
    for (key in model.attributes) {
      _results.push(this._updateAttributeConnector(null, key));
    }
    return _results;
  };

  ViewModel.prototype._onModelChange = function() {
    var key, _results, _results1;
    if (this.__kb.model._changed) {
      _results = [];
      for (key in this.__kb.model.attributes) {
        _results.push(this.__kb.model.hasChanged(key) ? this._updateAttributeConnector(this.__kb.model, key) : void 0);
      }
      return _results;
    } else if (this.__kb.model.changed) {
      _results1 = [];
      for (key in this.__kb.model.changed) {
        _results1.push(this._updateAttributeConnector(this.__kb.model, key));
      }
      return _results1;
    }
  };

  ViewModel.prototype._updateAttributeConnector = function(model, key) {
    var vm_key;
    vm_key = this.__kb.internals && _.contains(this.__kb.internals, key) ? '_' + key : key;
    return this[vm_key] = kb.AttributeConnector.createOrUpdate(this[vm_key], model, key, this._createOptions(key));
  };

  ViewModel.prototype._createOptions = function(key) {
    var options;
    if (this.__kb.children) {
      if (this.__kb.children.hasOwnProperty(key)) {
        options = this.__kb.children[key];
        if (typeof options === 'function') {
          options = {
            view_model: options
          };
        }
        options.options = {
          read_only: this.__kb.read_only,
          store: this.__kb.store
        };
        return options;
      } else if (this.__kb.children.hasOwnProperty('create')) {
        return {
          create: this.__kb.children.create,
          options: {
            read_only: this.__kb.read_only,
            store: this.__kb.store
          }
        };
      }
    } else if (this.__kb.create) {
      return {
        create: this.__kb.create,
        options: {
          read_only: this.__kb.read_only,
          store: this.__kb.store
        }
      };
    }
    return {
      read_only: this.__kb.read_only,
      store: this.__kb.store
    };
  };

  return ViewModel;

})(Knockback.ViewModel_RCBase);

Knockback.viewModel = function(model, options) {
  return new Knockback.ViewModel(model, options);
};
